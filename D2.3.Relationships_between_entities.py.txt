8:37 19.10.2023

В прошлом юните мы спроектировали сущности «Заказ», «Сотрудник», 
«Продукт» и «Позиция в заказе». Однако мы намеренно опустили один важный момент. 
Эти сущности не являются независимыми друг от друга. Более того, они непосредственно 
связаны друг с другом.

icon Поэтому в этом юните мы разберёмся:

* какие бывают связи;
* где какую связь использовать;
* что такое ключи и какие бывают виды ключей;
* как создавать ключи с помощью SQL.

Давайте подумаем:

* как каждый заказ связан с одним из сотрудников;
* как каждая позиция в заказе связана с каким-то конкретным продуктом;
* и вместе с этим, как каждая позиция в заказе связана с самим заказом.

Итак, мы имеем связи между сущностями.

Базы данных, в которых на этапе проектирования заложены предопределённые 
связи между сущностями, называют реляционными.
Именно такие базы данных мы и будем обсуждать в нашем курсе. Однако стоит 
понимать, что есть и другие способы хранения данных, и о некоторых из них 
можно прочитать в этой статье. Если вы не имели опыта работы с базами данных, 
рекомендуется ознакомиться со статьёй после изучения этого юнита.

Существует три основных типа связей (отношений) между сущностями:

* Один к одному.
* Один ко многим.
* Многие ко многим.

Рассмотрим их по порядку.

Один к одному
Этот тип связи между сущностями присутствует, когда один из объектов одной сущности 
связан только с одним объектом другой сущности.
Несколько улучшим нашу схему базы данных.
Мы прекрасно понимаем, что не все сотрудники работают с клиентами. Допустим, у нас 
есть и такие сотрудники, назовем их «Официанты», а также есть «Менеджер». И менеджер, 
очевидно, не занимается прямой работой с клиентами. Таким образом имеем, что у нас 
есть сущность «Сотрудник», которая является общей для двух других сущностей «Официант» 
и «Менеджер». Естественно, что каждый объект сущности «Официант» является в то же время 
и объектом сущности «Сотрудник». И связь между этими двумя объектами однозначна, 
ведь в реальности это один и тот же человек.

Конечно, это является необходимым, если нужно иметь дополнительные атрибуты для 
сущностей «Официант» и «Менеджер».

Один ко многим

Пожалуй, это наиболее используемый тип связи между сущностями.

Такая связь рождается, когда объекту одной сущности может соответствовать 
несколько объектов другой сущности. Стоит понимать, что фактически объекту 
первой сущности может соответствовать один объект второй сущности или даже 
ни одного, но применение данного типа связи позволяет создать множество связей.

И именно эта связь обеспечивает отношения между сущностями «Заказ» и «Сотрудник». 
Каждому «Сотруднику» может соответствовать множество «Заказов». Аналогично с 
сущностью «Позиция в заказе». С одной стороны, каждая позиция относится к 
конкретному заказу, с другой — в заказе может быть одна или много позиций.

Такая связь действительно является наиболее используемой. Отчасти это заключено 
вообще в природе связей между любыми объектами. Каждый объект, каким бы мы его 
не выбрали, как правило, может быть связан с большим количеством объектов. С другой 
стороны, ещё один тип связи, который мы рассмотрим далее, также может быть реализован 
с помощью связи «один ко многим».

Многие ко многим

Мы видели пример такой связи и в нашем образце. У нас есть сущности: 
«Заказ» и «Продукт». Очевидно, что в каждом заказе может быть много продуктов. 
И в то же время каждый продукт может быть в нескольких заказах. Естественно, 
имеется в виду не каждый конкретный физический объект (бургер), а именно 
абстрактный тип, который хранится в сущности «Продукт». Таким образом мы 
имеем широкую сеть взаимосвязанных объектов из двух таблиц.

Такая связь может быть представлена в виде схемы. Математически этот объект 
называется двудольным графом, но нам здесь важно обратить внимание на то, 
что каждый объект одного типа может быть связан с произвольным количеством 
объектов другого типа.

В теории это выглядит так. На практике же, когда мы реализуем такую связь 
мы всегда должны иметь три таблицы:

первые две TableA и TableB относятся к исходным объектам обоих типов;
третья таблица TableA_B хранит в себе связи между объектами первых таблиц.

Например, давайте посмотрим на эту картинку внимательно и попытаемся понять, 
какие объекты будут связаны. В частности, обратим внимание на объект из первой 
таблицы, выделенный розовым цветом. Он связан с объектами промежуточной таблицы: 
соответственно с первым, вторым и пятым объектами. В свою очередь, они связаны 
с тремя объектами второй «оригинальной» таблицы: с красным, оранжевым и серым объектами.

Как мы увидим при знакомстве с реализацией в Django, связь «многие ко многим» 
неявно всегда содержит эту промежуточную таблицу, но явно мы можем её и не определять. 
Такая необходимость возникает только тогда, когда для каждой связи нам нужно хранить 
какие-то дополнительные данные, например, о количестве продуктов в заказе.

Задание 2.3.1

Допустим, в проекте есть такие сущности как Автор и Книга, какая между ними может 
быть связь (без учёта двойного авторства и соавторства)?

один к одному
один ко многим +
многие ко многи

Делайте физические упражнения! Как недавно стало известно, во время физических 
упражнений вырабатываются вещества, которые подпитывают нейроны. Так растут 
новые и более сильные синапсы — связи между нейронами. Прогулки на свежем 
воздухе, бег, прыжки на скакалке — вам подойдёт всё что угодно. :)

Ключи

На текущий момент мы выяснили, что база данных — это совокупность сущностей (таблиц).

Каждая сущность может содержать строки или объекты, обладающие некоторыми атрибутами. 
Между сущностями также могут быть выстроены связи — «один к одному», «один ко многим», 
«многие ко многим». Однако остаётся вопрос — как это реализуется?

Для того чтобы построить связь между объектами из двух таблиц (и сейчас даже неважно 
какого типа связь), нам необходимо каким-то образом отличать объекты в каждой таблице 
и уметь к ним обращаться. Вспомним, что каждый объект сущности (каждая строка) 
является уникальным. Это обеспечивается естественным или искусственным путём. 
Естественный путь — выбор какого-то одного атрибута из предметной области, который 
гарантированно является уникальным для каждого объекта (штрихкод продукта, табельный 
номер сотрудника, ISBN книги и т. д.). Искусственный путь — добавление нового атрибута, 
выступающего счётчиком объектов. Именно искусственным путем мы шли, когда создавали 
таблицы в предыдущей части юнита: мы добавляли атрибуты product_id, order_id и т. д.

Вне зависимости от того, каким путём мы идем при обеспечении уникальности, задаётся 
так называемый первичный ключ.

Чтобы не усложнять, для простоты скажем, что первичный ключ — это атрибут, 
обеспечивающий уникальность.
Для желающих слегка углубиться в то, какими бывают первичные ключи, можно 
oбратиться к этой статье.

Как только мы имеем первичный ключ в исходной таблице, мы можем создавать связь из 
другой таблицы, объявляя в ней внешний ключ.

Внешний ключ, опять же без необязательной строгости, — это атрибут, содержащий в 
себе значение первичного ключа строк таблицы, с которой строится связь.
Давайте проиллюстрируем это на примере.

Вернёмся к базе данных интернет-магазина. У нас есть таблица «Продукты», в которой 
хранится меню ресторана. В этой и следующей таблицах не интересующие нас данные 
заменены многоточиями. Стоит понимать, что это сделано для демонстрации наиболее 
важных для нас вещей, хотя на самом деле пропусков в этих «ячейках» нет.

Table «Products»

product_id	name	price
001		...	...
002		...	...
...		...	...
Table «Products_Orders»

product_order_id	product		in_order	amount
0001			001		...	    	...
0002			001		...	    	...
0003			002		...	    	...
0004			001		...	    	...
0005			002		...	    	...

Как можем видеть, в таблице «Products_Orders» мы создали свой первичный 
ключ product_order_id — некий уникальный идентификатор каждого объекта 
сущности, а также определили внешний ключ product, который ссылается на 
первичный ключ таблицы «Products». Тем самым в каждой строке таблицы 
Product_Order мы имеем однозначную связь с какой-то из строк таблицы «Products»:

позиции с первичными ключами 0001, 0002, 0004 ссылаются на продукт с идентификатором 001;
позиции с остальными идентификаторами 0003, 0005 — на продукт с идентификатором 002.
Тем самым мы можем видеть пример создания связи «один ко многим» с помощью внешнего ключа.

Задание 2.3.2

Ключ — это...

уникальное поле +
неуникальное поле

Создание ключей с помощью SQL

Сначала посмотрим, как мы должны модицифировать созданные нами в прошлом юните 

таблицы Orders, Products, Staff. Начнём с таблицы Orders.

Здесь в качестве первичного ключа выступает атрибут order_id:

CREATE TABLE ORDERS (
    order_id INT AUTO_INCREMENT NOT NULL,
    time_in DATETIME NOT NULL,
    time_out DATETIME,
    cost FLOAT NOT NULL,
    pickup INT NOT NULL,    
    PRIMARY KEY (order_id)
);
Мы добавили строку PRIMARY KEY (order_id), которая и выполняет наше желание.

Задание 2.3.3
Возьмите таблицы Products и Staff, созданные в конце прошлого юнита и 
модифицируйте их, добавив определение первичного ключа.

Ответ

CREATE TABLE PRODUCTS (
    product_id INT AUTO_INCREMENT NOT NULL,
    name CHAR(255) NOT NULL,
    price FLOAT NOT NULL,

    PRIMARY KEY (product_id)
);

CREATE TABLE STAFF (
    staff_id INT AUTO_INCREMENT NOT NULL,
    full_name CHAR(255) NOT NULL,    
    position CHAR(255) NOT NULL,
    labor_contract INT NOT NULL,

    PRIMARY KEY (staff_id)
);

Внешний ключ определяется аналогичным способом. Рассмотрим на примере 
построения связи «один ко многим». В зависимой таблице (в которой «много» объектов) 
необходимо добавить строку, похожую на ту, что мы использовали для создания 
первичного ключа:

FOREIGN KEY (имя_атрибута) REFERENCES Основная_Таблица (первичный_ключ)

Давайте сразу применим это к нашим таблицам. В таблице заказов Orders в нашей 
изначальной задумке мы имели атрибут staff, который должен указывать на сотрудника, 
выполнившего заказ. Давайте вновь модифицируем эту таблицу, создав внешний ключ к 
таблице Staff.

CREATE TABLE ORDERS (
    order_id INT AUTO_INCREMENT NOT NULL,
    time_in DATETIME NOT NULL,
    time_out DATETIME,
    cost FLOAT NOT NULL,
    pickup INT NOT NULL,    staff INT NOT NULL,
    
    PRIMARY KEY (order_id),
    FOREIGN KEY (staff) REFERENCES STAFF (staff_id)
);
Отлично! Первая связь построена! Сделаем последний рывок, полностью создав таблицу 
«Products_Orders» с нуля.

Задание 2.3.4

При помощи SQL создайте таблицу PRODUCTS_ORDERS, которая должна:

* Содержать атрибут product_order_id, который предполагается целочисленным, автоматически 
  увеличивающимся на 1 и тем самым должен стать первичным ключом этой таблицы.
* Содержать атрибут product, который ссылается на первичный ключ таблицы Products.
* Содержать атрибут in_order, который ссылается на первичный ключ таблицы Orders.
* Содержать атрибут amount, который определяет количество конкретного продукта в заказе. 
  Мы предполагаем, что это целое число.

Ответ

CREATE TABLE PRODUCTS_ORDERS (
    product_order_id INT AUTO_INCREMENT NOT NULL,
    product INT NOT NULL,
    in_order INT NOT NULL,
    amount INT NOT NULL,
    
    PRIMARY KEY (product_order_id),
    FOREIGN KEY (product) REFERENCES PRODUCTS (product_id),
    FOREIGN KEY (in_order) REFERENCES ORDERS (order_id)
);
И это большой шаг в построении баз данных, потому что только что была реализована не 
просто таблица с двумя внешними ключами, а самая настоящая промежуточная таблица для 
связи «многие ко многим». Ведь именно таким образом она и создаётся, если вспомнить 
определение выше — каждая строка таблицы должна ссылаться на какой-то объект из первой 
исходной таблицы (в нашем случае — PRODUCTS) и в то же самое время на объект из второй 
исходной таблицы — ORDERS из примера.

Задание 2.3.5

Внешний ключ создаётся с помощью...

PRIMARY KEY
FOREIGN KEY +

Задание 2.3.6

Внутренний ключ создаётся с помощью...

PRIMARY KEY +
FOREIGN KEY

Задание 2.3.7

Допустим, в проекте есть сущность Зарегистрированный пользователь и Автор, какая между 
ними может быть связь (без учёта творческих псевдонимов)?
 
один к одному +
один ко многим
многие ко многим

Задание 2.3.8

Допустим, в проекте есть сущность Автор и Жанры, какая между ними может быть связь?

один к одному
один ко многим
многие ко многим +

Мир проектирования баз данных огромный и невероятно глубокий. Это знакомство 
является необязательным сейчас, но желательным, поэтому если чувствуете в себе силы, 
можно обратиться к дополнительным источникам.

Дополнительные материалы
Основы проектирования баз данных. Нормализация базы данных.
Глава 2 из этого источника отчасти повторит то, что обсуждалось нами здесь, но с 
другими примерами и более подробной информацией. Большинство из этого будет уже знакомо.
Эта статья раскрывает некоторые нюансы удаления данных в связанных таблицах, 
которые нужно учитывать уже на этапе проектирования.
И ещё один очень большой, но столь же классный, материал от этого же автора.
 
Надеемся, с каждым разом понимания становится всё больше, а пока подведём итог пройденных тем:

* узнали, какие бывают связи;
* поняли, как связи использовать;
* разобрались, какие бывают ключи;
* узнали, как создавать ключи с помощью SQL.

Проект News Portal

В конце прошлого юнита вы начали думать над сущностями, описывающими 
приложение News Portal. 

nlp	Какими связями обладают сущности в базе данных этого приложения. Какой тип они имеют?