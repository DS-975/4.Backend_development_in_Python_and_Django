Что ж, тема, сразу скажем, не из простых, поэтому вначале очень важно детально 
разобраться с теорией, а конкретно в данном юните речь пойдёт о том:

* что такое идентификаторы;
* как устроена база данных;
* что такое сущности в базе данных;
* и немного про язык программирования SQL.

Обратите внимание: начиная с этого модуля, примеры запросов будут указываться для SQLite.

Идентификаторы
В начале изучения языка Python мы познакомились с понятием уникального идентификатора объектов данных. Мы говорили о том, что за каждым объектом, будь то число или сложный составной объект (как, например, объект класса LinkedList, созданного нами в теме «Алгоритмы и структуры данных»), закреплено целое число — уникальный идентификатор. Он тесно связан с адресом ячейки памяти, в которой хранится этот объект.

Задание 2.2.1

Как получить значение уникального идентификатора объекта obj?
Ответ: id(obj)

Компилятор Python автоматически присваивает это число всем объектам. 
Зачем ему это нужно? Чтобы иметь возможность различать объекты, даже если 
они имеют одинаковое содержание. Удобно, согласитесь?

В нашей повседневной жизни происходит ровно то же самое. Каждый документ: 
паспорт, страховое свидетельство или документ о собственности, имеет свой 
уникальный номер, позволяющий найти его в списке всех документов. Когда вы получаете 
онлайн-заказ в точке выдачи, вас, как правило, попросят назвать номер заказа — 
уникальное число (или набор цифр с буквами), чтобы быстро и эффективно его найти. 
В библиотеке мы встречаем библиотечные индексы, в обычных магазинах штрих-коды.

Базы данных
Везде и всюду мы встречаем объекты и их идентификаторы. Этот же принцип лежит в 
основе организации данных в электронном виде. В компьютере данные хранятся, 
как правило, в базах данных.

База данных — это упорядоченный набор структурированной информации или данных, 
которые обычно хранятся в электронном виде в компьютерной системе.
Присваивание каждому объекту идентификатора обеспечивает упорядоченность базы 
данных — каждый объект имеет порядковый номер.

Помимо упорядоченности, данные удобно хранить структурированно. В простейшем 
виде базу данных можно представлять в виде таблицы (или нескольких таблиц). 
Рассмотрим таблицу, в которой хранятся все позиции заказов в нашем воображаемом 
интернет-магазине.

Номер заказа	Пункт самовывоза	Название позиции	Кол-во	Объём	Цена позиции	Стоимость заказа	Время заказа	Время выдачи
101	Да	Чистящее средство для монитора	2	0.4 л	109 р.	218 р.	20.10.2020 15:35	20.10.2020 15:40
102	Нет	Витая пара	1	5 м	208 р.	384 р.	20.10.2020 16:57	20.10.2020 17:08
102	Нет	Набор коннекторов RJ45	1	бол.	77 р.	384 р.		
102	Нет	Чистящее средство для монитора	1	0.3 л	99 р.	384 р.		
И это далеко не вся информация, которая может храниться по заказу. Также может храниться: 
информация о платеже, тип упаковки каждой позиции, даже её хрупкость, а также имя сотрудника, 
который оформлял/готовил/отдавал заказ. И ещё много-много всего.

Казалось бы, всё хорошо… Но давайте посмотрим внимательно на эту таблицу. Что можно в ней 
заметить?

* Во-первых, отсутствие данных в некоторых ячейках. С одной стороны, по заказу 102 
  мы имеем дату и время в первой строке этого заказа, но что с другими? Если мы имеем  
  дело с маленькой таблицей, то можем интуитивно восстановить пропущенные данные.

* Во-вторых, можно заметить повторение общей информации о заказе в каждой строке  
  таблицы. Опять же для маленькой таблицы, где можно все данные просмотреть одним  
  глазом, это не страшно. Но представьте, если эта таблица реально будет применяться  
  каком-нибудь большом интернет-магазине. Чтобы хранить заказ из 10 позиций, мы в  
  каждой строке таблицы будем держать общую стоимость товаров, время оформления и  
  выдачи заказа (если, например, всё-таки заполним пропуски) и ещё множество других  
  данных, которые мы не включили в таблицу. Насколько это целесообразно?

* В-третьих, у нас есть столбец «Объём». Очень абстрактно. Ведь «Объём» в случае  
  жидкости имеет действительно объём — 0.3 л или 0.4 л для позиции «Чистящее  
  средство для монитора». Для позиции «Витая пара» было бы странно хранить именно  
  объём, но мы можем хранить длину провода в метрах (предоставляется выбор из  
  кабелей на 1, 2 и 5 метров). Аналогично для «Набор коннекторов RJ45». Однако  
  для других позиций объём будет отсутствовать за ненадобностью. Например, как  
  у мониторов, ноутбуков и клавиатур.

* В-четвертых, если в первой строке написать «Чистящее средство для монитора»,  
  а в последней совершить ошибку и написать, например, «Чистящее средство монитора»,  
  то программа, работающая с базой данных, может не понять, о какой позиции  
  идет речь, ведь её вообще не существует!

* Учитывая это и ещё многие другие детали, можно сказать, что описанная таблица,  
  конечно, может применяться, но она неудобна, неэффективна и даже может породить  
  большое количество ошибок при работе с ней.

Задание 2.2.2

На что больше всего похожа база данных?
Word-файл
Excel-файл +
Python-скрипт

Сущности базы данных
Здесь нам и пригодится многолетний опыт специалистов в работе с базами данных. 
При организации данных в базах используются сущности.

Каждая сущность — это, как правило, некоторый объект из реального мира. Он может 
быть как физически существующим (стол, стул, банковская карта, человек) или 
абстрактным (человек создаёт стол, покупатель формирует заказ).
И для каждой такой сущности, физической или абстрактной, мы создаём таблицу.

У каждой сущности есть атрибуты или поля — некоторые свойства, характеристики 
объекта сущности.
Например, в представленной выше таблице у нас точно есть сущность «Заказ», 
у которой есть атрибуты «Стоимость заказа», «Время оплаты заказа», «Время выдачи заказа» 
и т. д. Есть и другие сущности, но какие?

При проектировании базы данных, мы должны сначала описать её концептуально
 — ответить на вопросы: «Какие данные есть?» и «Что с ними происходит?». 
Как правило, все существительные и большинство глаголов будут означать 
какие-то сущности в БД.

Попробуем придумать сущности базы данных заказов нашего интернет-магазина, 
а также ответим на вопрос: «Какими атрибутами они могут обладать?».


Сущность	Примечание	Атрибуты
Заказ	Эту сущность мы уже пытались описать выше. Доработаем её.	
Номер заказа
Время оформления заказа
Время выдачи заказа
Стоимость заказа
Сотрудник, который выдал заказ
Пункт самовывоза или доставка
Продукт	Эта таблица, по своей сути, описывает каталог.	
Номер продукта (да, каждый продукт в каталоге тоже имеет свой номер!)
Название (например, Витая пара, 3 м)
Тип продукта (провод, компьютер, экран и т. д.)
Цена
Позиция в заказе	Эта сущность описывает поведение «покупатель выбирает продукт»	
Заказ
Продукт
Количество
Сотрудник		
Индивидуальный номер
ФИО
Должность
Номер трудового договора (через который можно найти более подробную информацию о сотруднике)

Это простейший пример реорганизации созданной нами таблицы на несколько сущностей. 
Такое разбиение поможет избежать проблем, которые мы описали выше. Конечно, и такую 
схему можно ещё совершенствовать по многим пунктам, но она уже намного более 
эффективна и удобна в применении, чем первая таблица.

Одной из важных особенностей атрибутов сущностей является то, что они должны 
быть однородны. Иными словами, если атрибут представлен, например, числом, 
то в атрибут нельзя записать строку. Атрибут описывается определённым типом 
данных или, можно сказать, строго типизирован. В этом описание таблиц 
сущностей базы данных отличается, например, от двумерного списка в Python. 
В списках мы можем хранить неоднородные данные. В колонке таблицы, 
соответствующей какому-то атрибуту сущности, могут находиться данные 
только одного типа.

Задание 2.2.3
1/1 point (graded)
Какие утверждения верны?
A. Можно записать число в строковый атрибут.+
B. Можно записать строку в числовой атрибут.
C. Можно записать целое число в атрибут с плавающей точкой. +
D. Можно записать число с плавающей точкой в целочисленный атрибут.

Язык SQL
Естественно предположить, что таблицы-сущности могут (и должны быть!) 
описаны строгим образом. Пользуясь фреймворком Django, мы в следующей 
части этого модуля, научимся адаптировать Python для создания сущностей 
в базах данных (и даже будем строго описывать типы особым образом). 
Однако Django будет «переводить» написанный нами код на Python в язык, 
на котором можно «общаться» с базой данных.

Этот язык называется SQL — Structured Query Language — язык структурированных запросов.

На нём пишутся команды (запросы, в терминологии баз данных), с помощью 
которых можно создавать и удалять сущности, а также создавать, искать, 
обновлять и удалять CRUD-объекты (create, read, update, delete) сущностей. 
Очень подробно на нём останавливаться пока что не будем, но познакомимся 
лишь с некоторыми основами языка. Нам это нужно для того, чтобы хотя бы 
в общих чертах понимать, как устроены базы данных в своей основе. А также 
для того чтобы код, написанный на SQL, не пугал юных падаванов-разработчиков. :)

Код, написанный на SQL, как правило, сохраняется в файлах вида database.sql. 
Сейчас мы посмотрим, как с помощью этого языка можно описать создание таблиц в базе данных.

Основная команда, которая будет нами использоваться — это CREATE TABLE.

Например, заголовок создания таблицы ORDERS, хранящей заказы, будет выглядеть так:

CREATE TABLE ORDERS (
);

Далее наша задача состоит в том, чтобы описать атрибуты сущности. Как мы уже 
говорили, каждый атрибут имеет определённый тип.

Базовые типы схожи с аналогичными в Python:

INT — целочисленный тип;
FLOAT — числа с плавающей точкой;
CHAR(size) — хранение строк до 255 символов (длина указывается в size);
TEXT — хранение больших текстовых данных;
DATETIME — атрибуты позволяют хранить дату и время.
Этих типов данных, используемых в SQL, нам сейчас будет достаточно. 
Более того, они являются универсальными. Дело в том, что для работы с 
базами данных используются различные СУБД (системы управления базами данных). 
Разные СУБД поддерживают различные диалекты SQL. Общие принципы остаются одинаковыми, 
но всё же отличия имеются. Пока что нам достаточно универсальных типов, 
а знакомство с особенностями разных СУБД отложим на потом.

Чтобы описать атрибут сущности, необходимо пользоваться следующей конструкцией 
языка внутри конструкции создания таблицы:

CREATE TABLE table_name (
    field_name TYPE
);
Опишем некоторые (пока что не все) атрибуты сущностей базы данных нашего 
интернет-магазина:

1
Сущность «Заказ»
CREATE TABLE ORDERS (
    order_id INT AUTO_INCREMENT NOT NULL,
    time_in DATETIME NOT NULL,
    time_out DATETIME NOT NULL,
    cost FLOAT NOT NULL,
    pickup INT NOT NULL
);
Здесь мы дополнительно использовали несколько свойств атрибутов.

AUTO_INCREMENT указывает базе данных, что она должна сама озаботиться 
тем, чтобы записать сюда значение. Помните, как Python автоматически 
назначал каждому объекту идентификатор. Именно это же мы указываем 
базе данных делать с данным атрибутом, он служит уникальным идентификатором, 
и мы требуем, чтобы БД сама назначала порядковый номер каждой строке.

Также в каждом атрибуте появилось таинственное NOT NULL. И не зря. 
Когда мы создавали первую большую таблицу, обнаружили в ней пропуски — 
отсутствие значений. Мы сошлись на том, что так делать не очень хорошо. 
И чтобы вдруг случайно такой ситуации не случилось в базе данных, 
мы прямо указываем, что каждое поле должно иметь значение. Иными 
словами быть ненулевым (not null).

В этой сущности мы создали атрибуты:

* order_id (целочисленный атрибут с автоинкрементом) — уникальный 
  идентификатор заказа, который база данных будет автоматически назначать каждой строке;

* time_in (тип даты/времени) — хранит время оформления заказа;

* time_out (тип даты/времени) — хранит время выдачи заказа;

* cost (число с плавающей точкой) — стоимость заказа в рублях;

* pickup (целочисленный атрибут) — доставка (0) или самовывоз (1). Мы использовали 
  целочисленный тип (который, как вы помните, хорошо приводится к логическому типу) 
  только с двумя значениями.

В данной таблице мы на текущий момент не добавили только сотрудника. Мы обязательно вернёмся к нему в следующем юните, а сейчас продолжим описание других таблиц на языке SQL.

2
Сущность «Продукт»
Опишем таблицу PRODUCTS, соответствующую сущности «Продукт».

CREATE TABLE PRODUCTS (
    product_id INT AUTO_INCREMENT NOT NULL,
    name CHAR(255) NOT NULL,
    price FLOAT NOT NULL
);
Здесь мы имеем:

* product_id (целочисленный атрибут с автоинкрементом) — уникальный идентификатор 
  товара в каталоге;

* name (строка до 255 символов) — название товара;

* price (число с плавающей точкой) — цена товара.

Задание 2.2.4

С помощью языка SQL и написанных ранее примеров, создайте таблицу STAFF, которая имеет 
следующие атрибуты:

* staff_id (целочисленный атрибут с автоинкрементом) — уникальный идентификатор 
  каждого сотрудника;

* full_name (строка до 255 символов) — ФИО сотрудника;

* position (строка до 255 символов) — должность сотрудника;

* labor_contract (целочисленный атрибут) — номер трудового договора.

Ответ

CREATE TABLE STAFF (
    staff_id INT AUTO_INCREMENT NOT NULL,
    full_name CHAR(255) NOT NULL,    
    position CHAR(255) NOT NULL,
    labor_contract INT NOT NULL
);

Как вы могли заметить, здесь мы описали не все атрибуты, а опустили те из них, 
которые являются связующими между таблицами. Это связано с тем, 
что прежде чем создавать связи, нужно понять, какие они бывают 
и зачем они вообще нужны, этим мы займёмся в следующем юните.



Задание 2.2.5

Что обязательно должно быть у одной сущности в базе данных?
Уникальный идентификатор +
Поле ID

Задание 2.2.6
1/1 point (graded)
Выберите SQL-скрипт, который разрешает полю time_in быть пустым.

CREATETABLE ORDERS (
    order_id INT AUTO_INCREMENT NOT NULL,
    time_in DATETIME NOT NULL,
    time_out DATETIME NOT NULL,
    cost FLOAT NOT NULL,
    pickup INT NOT NULL
);

CREATETABLE ORDERS (                       +
    order_id INT AUTO_INCREMENT NOT NULL,  +
    time_in DATETIME,                      +
    time_out DATETIME NOT NULL,            +
    cost FLOAT NOT NULL,                   +
    pickup INT NOT NULL                    +
);                                         +

CREATETABLE ORDERS (
    order_id INT AUTO_INCREMENT NOT NULL,
    time_in DATETIME NULL,
    time_out DATETIME NOT NULL,
    cost FLOAT NOT NULL,
    pickup INT NOT NULL
);

Мы прошли с вами такие важные и объёмные темы как:

* идентификаторы,

* базы данных,

* сущности в базе данных,

* SQL.

Что-то мы рассмотрели не в полном объёме, так как невозможно всё уместить в одном 
юните. Но постепенно двигаясь дальше, вы станете понимать больше, так что в следующем 
юните, как мы уже писали, мы разберём связи.

Проект News Portal
В течение этого и следующих модулей мы будем постепенно приближаться к созданию 
полноценного приложения новостного портала News Portal. Предполагается, что на 
нём можно будет смотреть новости и читать статьи. Каждая статья/новость может 
относиться к одной или нескольким категориям. Более того, зарегистрированные 
пользователи сами смогут писать статьи/новости на новостной портал.

В конце каждого юнита вам будут предложены различные вопросы, над которыми можно 
поразмышлять на основе изученного материала. А в конце изучения всего модуля вы 
приступите к разработке этого приложения.

После изученного юнита про сущности подумайте, какими сущностями и их 
атрибутами можно описать создаваемое приложение.